; Parallax distorter 2
; ====================
; Fullscreen (STe, without stabilization switches)
; Per-pixel x-y distortion (using STe HW-scroll per line)
; 25 kHz sampled sound
; Code by Solomon of Gash/Corrosion/Sunshine productions
;                 [didn't release anything on Atari...]
; Contact: andreas.sigfridsson@gmail.com
; 
; (c) Copyright 2018 Andreas Sigfridsson
; 
; I have only tested this in Hatari 2.0/2.1. Please report whether this
; works on real STe hardware or not. I would be extra grateful for
; patches to make it work. I suspect that there could be timing issues
; with the fullscreen code, and/or (perhaps more likely) the timing of
; changing the hardware scroll registers (hscroll and hskip). If you
; want public discussions, I'm "sigge" on atari-forum.org. I'd love to
; hear your comments!
; 
; The compiled binary requires 1 Mbyte of RAM. To compile it, I use vasm.
; The macros and repeats seems to break devpac.
; "vasmm68k_mot -Ftos -tos-flags=1 paradst2.s -o paradst2.tos"
; 
; I release this code under GPL 2. I have also borrowed some init code,
; and more importantly, data files from Gunstick's release of the ULM
; parallax distorter screen (also released under GPL 2). The fullscreen
; code and DMA code I got from the DHS demo system.
; 
;   Background and details
; 
; Back in the 90's, I borrowed my friend Headcase's STe to play around
; with. Of special interest was the hw-scroll available, and I quickly
; wrote an x-disting scroller by changing the scroll register every
; line. I combined this with a movep-based "byte-bender" 8 pixel
; y-disting scroller, and I had a nice x-y disting scroller! I never
; thought of stacking the scrollers vertically, like Leonard's one in We
; were @, but once I saw it I knew exactly how it was done. A lovely
; remake of my absolute favorite screen ever; the Parallax distorter by
; Gunstick/ULM. This summer, I was thinking, couldn't Leonard's approach
; be used with a bit-bending (per-pixel y-dist) technique?
; 
; I spent may short moments counting cycles in my head, and I had my
; idea ready long before I had any emulator running to try it. It turned
; out that I counted a bit wrong, and my original idea wouldn't work. It
; was based on combining four 2-pixel-wide strips, where each strip
; could be preshifted by all combinations (the odd pixel shifted -2, -1,
; 0, +1 or +2 pixels vertically from the even). I eventually changed
; into combining two 4-pixel-wide strips, but then having to store many
; more combinations. By restricting the steepness of the y-curve to what
; would be readable anyway, only 9 combinations are necessary. This even
; gives quite some time to spare. I could have gone for higher font than
; the 20-pixel one in the ULM screen, but I wanted to use that one as a
; homage. And laziness ;-P I was quite happy to see that Gunstick put it
; all up - I thought I would have to rip it from youtube screengrabs or
; whatnot.
; 
; I wanted to make the synchronized code as fast as possible. That meant
; working with prepared tables, that included potential wraps so no
; checks would be necessary. I started with making both the horizontal
; and the vertical tables completely precalced, but it would need quite
; some combinations to do bouncing etc. In order to save RAM, the
; vertical dist table is generated each VBL before opening the top
; border (allowing for wrap checks). Furthermore, the original version
; preshifted the font in double height to completely obliterate wrap
; checks. This consumed too much RAM, though, and an alternative
; approach was conceived. The output stage of the combining code uses
; movep, which has a 16-bit displacement "for free". Thus, 20 merging
; routines are generated by the assembler, and the appropriate one is
; selected when building the vertical dist table. This allows for
; arbitrary shift in the vertical direction, without consuming more time
; in the synchronous part.
; 
; In order to call the appropriate merging functions (one per each
; 8-pixel strip, so in total ~60), a call stack is constructed with
; pointers to the merging routines. The merging routine ends with an
; rts, popping the pointer to the next copying routine and continuing
; down the chain. This also allows for other code to be interleaved at
; appropriate points. Each merging routine takes 4 scanlines to process
; 8x20 pixels, with interleaved border switches, playfield palette
; changes and x-dist register changes. There is still time for some
; 60-70 nops available on the last line of these four. This is followed
; by an increment of 1 or 7 to the screen destination pointer. Every
; fifth merging routine (i.e. every 20 lines), the screen address middle
; byte is reset to start from the top of the buffer.
; 
; Memory... Well, this screen kind of could fit into 512 kBytes.
; However, it would require a loader that can load it into low memory -
; it doesn't fit when TOS loads it like a normal executable. I thought
; of using the extra time available to do some delta packing of the
; sampled sound, like in the original ULM screen. Haven't got around to
; try it yet, though. The 25 kHz sound is now 164 kBytes. I have to cut
; the charset a bit to fit into 512k. With delta packing and a few other
; tweaks, one might be able to include the full charset too. I even
; contemplated storing only a preshifted buffer with the width of the
; screen, potentially allowing for a very large charset. With
; sufficiently slow scrolling, preshifting could be done realtime, one
; 8-pixel strip at a time.
; 
; Optimization... I thought of utilizing that spaces in the scrolltext
; would be much faster to copy (no merging necessary, only the
; background playfield data to copy which are same for each line).
; 
; At the moment, I avoid using 0 pixel hscroll offset. This messes up
; the hskip for the next line, and I couldn't get it to work. Also,
; Leonard seems to avoid it too; I'm not sure if there are some
; necessary changes to the border code for these cases (on real
; hardware). If that is the case, I think it could be tricky to solve.
; 
; Hope you have fun with the source!

	;; TODO
	;; make sure sound is the correct length for each frame
	;; 
	;; scr_low instead of hskip?
	;; reduce memory load
	;;   reduce wrap-protection overhead
	;;   use converted font space
	;;   non-masked font buffer?
	;;   realtime decompressed sample
	
	;;   preshifted font: 210k (reduced set) - 330k (full set)
	;;   screen (32 lines dbl-buf): 16k
	;;   scrolltext pointers: 5k
	;;   font (can be reused): 15k
	;;   colors: 11k
	;;   sample: 164k

	
SLOMO	equ	0		;to step slowly, for debugging, not 100% working
DBG	equ	0		;background colors debug
	
ENABLE_HDIST	equ	1
ENABLE_VDIST	equ	1
ENABLE_BOUNCE	equ	1
ENABLE_VBOUNCE	equ	1
ENABLE_SCROLL	equ	1

LINEWIDTH	equ	256
SCREENHEIGHT	equ	273
FONTHEIGHT  equ 20
FONTHEIGHT2	equ	24
;; SCREENSIZE    equ    LINEWIDTH*FONTHEIGHT
SCREENSIZE    equ    LINEWIDTH*32 ;for double buffer
NUMCHARS16  equ 79		  ;full charset is 95
NUMCHARS8   equ NUMCHARS16*2
NUMMASKS    equ 2
NUMSHIFTS   equ 9

;SKIPHEIGHT	equ
SKIPSHIFT	equ	FONTHEIGHT2*4
SKIPMASK	equ	NUMSHIFTS*SKIPSHIFT
SKIPCHAR	equ	NUMMASKS*SKIPMASK

HBOUNCE_LEN	EQU	164

	
NEG000SHIFT	equ	0*SKIPSHIFT
NEG001SHIFT	equ	1*SKIPSHIFT
NEG010SHIFT	equ	2*SKIPSHIFT
NEG011SHIFT	equ	0*SKIPSHIFT ;x
NEG100SHIFT	equ	3*SKIPSHIFT
NEG101SHIFT	equ	4*SKIPSHIFT
NEG110SHIFT	equ	0*SKIPSHIFT ;x
NEG111SHIFT	equ	0*SKIPSHIFT ;x

POSSHIFT	equ	8
	
POS000SHIFT	equ	0*SKIPSHIFT
POS001SHIFT	equ	5*SKIPSHIFT
POS010SHIFT	equ	6*SKIPSHIFT
POS011SHIFT	equ	0*SKIPSHIFT ;x
POS100SHIFT	equ	7*SKIPSHIFT
POS101SHIFT	equ	8*SKIPSHIFT
POS110SHIFT	equ	0*SKIPSHIFT ;x
POS111SHIFT	equ	0*SKIPSHIFT ;x

DBG_C0	MACRO
	ifne	DBG
	move.w	\1,$ffff8240.w
	endc

	ENDM


	section	text

	pea	start(pc)
	move.w	#38,-(sp)
	trap	#14
	addq.l	#6,sp

	clr.w	-(sp)
	trap	#1

start:
	lea	oldcpu(pc),a0
	move.l	sp,(a0)+
	lea	my_stack,sp
	move.w	sr,(a0)+
	move.w	#$2700,sr
	move.l	usp,a1
	move.l	a1,(a0)+

	moveq	#$12,d0
	bsr	ikbd_wrt
	moveq	#$1a,d0
	bsr	ikbd_wrt

	move.l	$408.w,old_408
	move.l	#exit_with_408,$408.w

	lea	oldvideo(pc),a0
	move.b	$ffff8260.w,(a0)+
	move.b	$ffff820a.w,(a0)+
	move.l	$ffff8200.w,(a0)+
	movem.l	$ffff8240.w,d0-d7
	movem.l	d0-d7,(a0)

	;; movem.l	black(pc),d0-d7
	;; movem.l	d0-d7,$ffff8240.w


	lea	oldvectors(pc),a0
	move.l	$68.w,(a0)+
	move.l	$70.w,(a0)+
	move.l	$114.w,(a0)+
	move.l	$118.w,(a0)+
	move.l	$120.w,(a0)+
	move.l	$134.w,(a0)+
	move.l	#nix,$68.w
	move.l	#vbl,$70.w
	move.l	#nix,$114.w
	move.l	#nix,$118.w
	move.l	#nix,$120.w
	move.l	#nix,$134.w

	lea	oldmfp(pc),a0
	move.b	$fffffa07.w,(a0)+
	move.b	$fffffa09.w,(a0)+
	move.b	$fffffa13.w,(a0)+
	move.b	$fffffa15.w,(a0)+
	move.b	$fffffa17.w,(a0)+
	move.b	$fffffa19.w,(a0)+
	move.b	$fffffa1b.w,(a0)+
	move.b	$fffffa1d.w,(a0)+

	bclr	#3,$fffffa17.w
	clr.b	$fffffa07.w
	clr.b	$fffffa09.w
;	ifne	keyboard
;	move.b	#%01000000,$fffffa09.w
;	endc

	bsr	waitvbl1
	move.b	#0,$ffff8260.w
	move.b	#2,$ffff820a.w

;	bsr	mfp_test

	jmp	screen
back:

	lea	my_stack,sp

	lea	oldmfp(pc),a0
	move.b	(a0)+,$fffffa07.w
	move.b	(a0)+,$fffffa09.w
	move.b	(a0)+,$fffffa13.w
	move.b	(a0)+,$fffffa15.w
	move.b	(a0)+,$fffffa17.w
	move.b	(a0)+,$fffffa19.w
	move.b	(a0)+,$fffffa1b.w
	move.b	(a0)+,$fffffa1d.w

	lea	oldvectors(pc),a0
	move.l	(a0)+,$68.w
	move.l	(a0)+,$70.w
	move.l	(a0)+,$114.w
	move.l	(a0)+,$118.w
	move.l	(a0)+,$120.w
	move.l	(a0)+,$134.w

	move.b	#2,$ffff820a.w
	bsr.s	waitvbl1
	move.b	#0,$ffff820a.w
	bsr.s	waitvbl1
	move.b	#2,$ffff820a.w
	bsr.s	waitvbl1

	lea	oldvideo(pc),a0
	move.b	(a0)+,$ffff8260.w
	move.b	(a0)+,$ffff820a.w
	move.l	(a0)+,$ffff8200.w
	movem.l	(a0),d0-d7
	movem.l	d0-d7,$ffff8240.w

	move.b	#0,$FFFF8265.w	;pix-scroll
	move.b	#0,$FFFF820F.w	;skip

	
	moveq	#$14,d0
	bsr.s	ikbd_wrt
	moveq	#$8,d0
	bsr.s	ikbd_wrt

	lea	oldcpu(pc),a0
	move.l	(a0)+,sp
	move.w	(a0)+,sr
	move.l	(a0)+,a1
	move.l	a1,usp

	move.l	old_408(pc),$408.w

	rts


vbl:
	add.w	#1,$468.w
	rte

waitvbl:
	move.w	$468,d0
.wait:
	cmp	$468,d0
	beq.s	.wait
	rts

waitvbl1:
	move.w	#9000,d0
waitvbl2:
	dbf	d0,waitvbl2
;waitvbl:
	lea	$ffff8209.w,a0
	movep.w	-8(a0),d0
waitvbl3:
	tst.b	(a0)
	bne.s	waitvbl3
	movep.w	-4(a0),d1
	cmp.w	d0,d1
	bne.s	waitvbl3
	rts

ikbd_wrt:
	lea	$fffffc00.w,a0
ik_wait:
	move.b	(a0),d1
	btst	#1,d1
	beq.s	ik_wait
	move.b	d0,2(a0)
	rts


old_408:
	dc.l	0
exit_with_408:
	lea	my_stack,sp
;	jsr	myexit
	move.l	old_408(pc),a0
	jmp	(a0)

exit:
;	move.l	my_reset+2,$42a.w
;	move.l	$42a.w,my_reset+2
	bsr	music_dma_exit
	movem.l	black(pc),d0-d7
	movem.l	d0-d7,$ffff8240.w

	bra	back

nix:
	rte

oldcpu:		ds.w	4
oldvideo:	ds.w	19
oldvectors:	ds.l	6
oldmfp:		ds.w	5
mfp_type:	ds.w	1
black:		ds.l	16


init_scrolltext:
	move.l	#fontconv,a0
	move.l	#fontconv2,a1
	moveq	#0,d0
.fontconvloop:
	moveq	#0,d0
	move.b	(a0)+,d0
	cmp.b	#-1,d0
	beq	.fontconv_over

	add.w	d0,d0
	move.b	(a0)+,(a1,d0.w)
	move.b	(a0)+,1(a1,d0.w)
	bra	.fontconvloop
.fontconv_over

	move.l	#scrolltext_prep,scroll_ptr
	
	move.l	#scrolltext,a0
	move.l	#scrolltext_prep,a1
	move.l	#fontconv2,a2
	move.l	#font_buffer,a3
.loop:
	moveq	#0,d0
	moveq	#0,d1
	moveq	#0,d2
	move.b	(a0)+,d0
	add.w	d0,d0
	move.b	(a2,d0.w),d1	;char idx
	move.b	1(a2,d0.w),d2	;num 16chars

	subq.w	#1,d1		;ULM list starts at 1
	lsl.w	#1,d1		;16char-8char
	subq.w	#1,d2		;dbf-loop
	mulu	#SKIPCHAR/4,d1
.loop2:
	;; move.l	a3,d3
	;; add.l	d1,d3
	move.w	d1,(a1)+
	;; add.l	#SKIPMASK,d3
	;; move.l	d3,(a1)+
	;; add.l	#SKIPCHAR-SKIPMASK,d3
	add.w	#SKIPCHAR/4,d1

	move.w	d1,(a1)+
	;; add.l	#SKIPMASK,d3
	;; move.l	d3,(a1)+
	add.w	#SKIPCHAR/4,d1

	dbra	d2,.loop2

	cmp.b	#-1,(a0)
	bne	.loop

	move.l	a1,scroll_ptr_wrap
	move.l	a1,a2

	;; fill wrap protection
	move.l	scroll_ptr,a0
	move.l	scroll_ptr_wrap,a1
.loop3:
	move.l	(a0)+,(a1)+
	;; move.l	(a0)+,(a1)+
	cmp.l	a0,a2
	bgt.s	.loop3

	ifeq	1
SCROLL_LENGTH_BYTES	equ	(scrolltext_end-scrolltext-4)*2
.loop:
	move.l	(a0),d0
	cmp.l	#-1,d0
	beq.s	.scroll_fin
	muls	#SKIPCHAR,d0
	add.l	#font_buffer,d0
	move.l	d0,(a0)+
	
	move.l	d0,SCROLL_LENGTH_BYTES(a1)
	move.l	d0,(a1)+
	add.l	#SKIPMASK,d0
	move.l	d0,SCROLL_LENGTH_BYTES(a1)
	move.l	d0,(a1)+
	bra.s	.loop
.scroll_fin:
	endc
	
	rts


screen:
	move.w	#$2300,sr	; enable VBL
	lea	my_stack,sp
;	jsr	waitvbl

	bsr	init_scrolltext

	DBG_C0	#$700
	bsr preshift_font
	DBG_C0	#$070
	bsr	preshift_sin
	DBG_C0	#$007
	bsr	init_wrap_tab
	DBG_C0	#$770
	bsr	precalc_hdist
	DBG_C0	#$707
	bsr	precalc_vdist
	DBG_C0	#$000

	move.l #pal,a0
	movem.l (a0),d0-d7
	movem.l d0-d7,$ffff8240.w

	ifeq	0
	move.l	#screen_buffer+$1fff,d0
	and.w	#$e000,d0
	else
	move.l	#screen_buffer+65535,d0
	clr.w	d0
	endc
	move.l	d0,a1
	move.l	d0,screen_ptr
	lsr.w	#8,d0
	move.l	d0,$ffff8200.w

	bsr	music_dma_init

loop:
	bsr	waitvbl

	bsr	setup_timera

	bsr	music_dma_play
	bsr draw_scroll		;sets up timer a and returns

	move.b	$fffffc02.w,key

	cmpi.b	#57,key
	bne	loop

	jmp exit

preshift_sin:
	move.l	#sin1024,a0
	move.l	#sin1024_6,a1
	move.l	#sin1024_15,a2
	move.l	#vdist_pattern,a3
	move.l	#sin1024,a4
	moveq	#0,d4
	move.w	#1024-1,d7
.loop
	move.w	(a0)+,d0
	asr.w	#1,d0
	move.w	d0,(a2)+
	asr.w	#5-1,d0
	asr.w	#6,d0
	add.w	d0,d0
	move.w	d0,(a1)+

	;;  hdist pattern
	move.w	d4,d0
	add.w	d0,d0		;d0 2x
	move.w	d0,d2
	add.w	d2,d2		;d2 4x
	add.w	d4,d0		;d0 3x frequency
	add.w	d4,d2		;d2 5x frequency
	add.w	#768*2,d0	;phase
	and.w	#1023*2,d0
	add.w	#0*2,d2	;phase
	and.w	#1023*2,d2
	move.w	(a4,d0.w),d0
	move.w	(a4,d2.w),d2
	move.w	(a4,d4.w),d1
	asr.w	#1+2,d0
	asr.w	#1+1,d1
	asr.w	#1+3,d2
	add.w	d1,d0
	add.w	d2,d0
	asr.w	#5,d0
	asr.w	#6-3,d0
	add.w	d0,d0		;even
	move.w	d0,(a3)+
	
	add.w	#2,d4
	dbra	d7,.loop

; one lap wrap protection
	move.l	#sin1024_6,a1
	move.w	#1024-1,d7
.loop2
	move.w	(a1),1024*2(a1)
	addq.l	#2,a1
	dbra	d7,.loop2

; one lap wrap protection
	move.l	#vdist_pattern,a1
	move.w	#1024-1,d7
.loop3
	move.w	(a1),1024*2(a1)
	addq.l	#2,a1
	dbra	d7,.loop3

	rts

preshift_font:
	;; first do all font combos for 0 shift
	;; then copy bottom half
	;; then do the shifts
	;; then re-copy the bottom half
	
	move.l #font,a0	 ; 4 words for each 95 character, repeated 20 times
	move.l #font_buffer,a1  ; NUMCHARS8*NUMMASKS*NUMSHIFTS*FONTHEIGHT2*4
	add.l #2*4,a1; skip for wrap buffer for second nibble (+/- 2 lines)

	move.w  #NUMCHARS16-1,d7
charloop:
	move.l  a0,a2
	move.l  a1,a3

	rept	FONTHEIGHT
	movep.l 0(a2),d0	;d0 first 8-char
	movep.l 1(a2),d1	;d1 second 8-char
	add.l   #95*4*2,a2	  ; step one line

	move.l  d0,d2
	and.l  #$f0f0f0f0,d2
	move.l  d2,(a3)
	add.l   #SKIPMASK,a3

	move.l  d0,d2
	and.l  #$0f0f0f0f,d2
	move.l  d2,(a3)
	add.l   #SKIPMASK,a3

	sub.l   #2*SKIPMASK,a3	; undo
;	add.l   #4,a3; add one line

	add.l	#SKIPCHAR,a3

	move.l  d1,d2
	and.l  #$f0f0f0f0,d2
	move.l  d2,(a3)
	add.l   #SKIPMASK,a3

	move.l  d1,d2
	and.l  #$0f0f0f0f,d2
	move.l  d2,(a3)
	add.l   #SKIPMASK,a3

	sub.l   #2*SKIPMASK,a3	; undo
	sub.l   #SKIPCHAR,a3	; undo
	add.l   #4,a3; add one line

	endr

	add.l   #8,a0 ; step one 16char
;	add.l   #NUMMASKS*NUMSHIFTS*FONTHEIGHT2*4,a1 ; step one char
	add.l	#2*SKIPCHAR,a1

	dbra	d7,charloop


; shift
	move.l #font_buffer+2*4,a0  ; NUMCHARS8*NUMMASKS*NUMSHIFTS*FONTHEIGHT2*4
	move.w #NUMCHARS8*NUMMASKS-1,d7

	move.l	#$88888888,d0
	move.l	#$44444444,d1
	move.l	#$22222222,d2
	move.l	#$11111111,d3
charloop_shift:
LIN	set	0
	rept	FONTHEIGHT

	move.l	((LIN)*4)(a0),a1 ; fetch unshifted
	move.l	((LIN+FONTHEIGHT-1)%FONTHEIGHT)*4(a0),a2 ; fetch neg1
	move.l	((LIN+FONTHEIGHT-2)%FONTHEIGHT)*4(a0),a3 ; fetch neg1
	move.l	((LIN+FONTHEIGHT-3)%FONTHEIGHT)*4(a0),a4 ; fetch neg1

PRESHIFTM	MACRO
	move.l	a1,d4
	and.l	d0,d4
	move.l	\1,d6
	and.l	d1,d6
	or.l	d6,d4
	move.l	\2,d6
	and.l	d2,d6
	or.l	d6,d4
	move.l	\3,d6
	and.l	d3,d6
	or.l	d6,d4
	ENDM

	PRESHIFTM	a1,a1,a2
	move.l	d4,LIN*4+NEG001SHIFT(a0)
	PRESHIFTM	a1,a2,a2
	move.l	d4,LIN*4+NEG010SHIFT(a0)
	;; PRESHIFTM	a1,a2,a3
	;; move.l	d4,LIN*4+NEG011SHIFT(a0)
	PRESHIFTM	a2,a2,a2
	move.l	d4,LIN*4+NEG100SHIFT(a0)
	PRESHIFTM	a2,a2,a3
	move.l	d4,LIN*4+NEG101SHIFT(a0)
	;; PRESHIFTM	a2,a3,a3
	;; move.l	d4,LIN*4+NEG110SHIFT(a0)
	;; PRESHIFTM	a2,a3,a4
	;; move.l	d4,LIN*4+NEG111SHIFT(a0)

	move.l	((LIN+1)%FONTHEIGHT)*4(a0),a2 ; fetch pos1
	move.l	((LIN+2)%FONTHEIGHT)*4(a0),a3 ; fetch pos1
	move.l	((LIN+3)%FONTHEIGHT)*4(a0),a4 ; fetch pos1

	PRESHIFTM	a1,a1,a2
	move.l	d4,LIN*4+POS001SHIFT(a0)
	PRESHIFTM	a1,a2,a2
	move.l	d4,LIN*4+POS010SHIFT(a0)
	;; PRESHIFTM	a1,a2,a3
	;; move.l	d4,LIN*4+POS011SHIFT(a0)
	PRESHIFTM	a2,a2,a2
	move.l	d4,LIN*4+POS100SHIFT(a0)
	PRESHIFTM	a2,a2,a3
	move.l	d4,LIN*4+POS101SHIFT(a0)
	;; PRESHIFTM	a2,a3,a3
	;; move.l	d4,LIN*4+POS110SHIFT(a0)
	;; PRESHIFTM	a2,a3,a4
	;; move.l	d4,LIN*4+POS111SHIFT(a0)

	;; addq.l	#4,a0		;next line
LIN	set	LIN+1
	endr

	;; sub.l	#FONTHEIGHT*4,a0
	add.l	#SKIPMASK,a0
	dbra	d7,charloop_shift
	

; copy 2 lines above and below for wrap protection for second nibble
	move.l #font_buffer,a0  ; NUMCHARS8*NUMMASKS*NUMSHIFTS*FONTHEIGHT2*4
	move.w #NUMCHARS8*NUMMASKS*NUMSHIFTS-1,d7
charloop_copy2:
	move.l	(FONTHEIGHT-2+2)*4(a0),(a0)
	move.l	(FONTHEIGHT-1+2)*4(a0),4(a0)
	move.l	8(a0),(FONTHEIGHT+2)*4(a0)
	move.l	12(a0),(FONTHEIGHT+1+2)*4(a0)
	add.l   #SKIPSHIFT,a0
	dbra	d7,charloop_copy2

	rts

	;; 63n
COPY5_63	MACRO
	movem.l	(a0)+,d0-d4	; 3n+2*5n = 13n

	or.l	(a1)+,d0	; 5*4n = 20n
	or.l	(a1)+,d1
	or.l	(a1)+,d2
	or.l	(a1)+,d3
	or.l	(a1)+,d4

	movep.l	d0,LINEWIDTH*((0+LINOFFSET)%FONTHEIGHT)(a4)	; 5*6n = 30n
	movep.l	d1,LINEWIDTH*((1+LINOFFSET)%FONTHEIGHT)(a4)
	movep.l	d2,LINEWIDTH*((2+LINOFFSET)%FONTHEIGHT)(a4)
	movep.l	d3,LINEWIDTH*((3+LINOFFSET)%FONTHEIGHT)(a4)
	movep.l	d4,LINEWIDTH*((4+LINOFFSET)%FONTHEIGHT)(a4)
NOPS_LEFT	set	NOPS_LEFT-63
	ENDM

	;; 87n
copy7	MACRO
	movem.l	(a0)+,d0-d6	; 12+7*8 = 68

	or.l	(a1)+,d0	; 7*16 = 112
	or.l	(a1)+,d1
	or.l	(a1)+,d2
	or.l	(a1)+,d3
	or.l	(a1)+,d4
	or.l	(a1)+,d5
	or.l	(a1)+,d6

	movep.l	d0,LINEWIDTH*0+LINOFFSET(a4)	; 7*24 = 168
	movep.l	d1,LINEWIDTH*1+LINOFFSET(a4)
	movep.l	d2,LINEWIDTH*2+LINOFFSET(a4)
	movep.l	d3,LINEWIDTH*3+LINOFFSET(a4)
	movep.l	d4,LINEWIDTH*4+LINOFFSET(a4)
	movep.l	d5,LINEWIDTH*5+LINOFFSET(a4)
	movep.l	d6,LINEWIDTH*6+LINOFFSET(a4)

; 68+112*3+168 = 572 (4 masks)
	;; 68+112+168 = 348/87 nops (2 masks)
	ENDM
	;; 1 line = 52/13 nops (no movem, 1 dreg)

	;; 75n
copy6	MACRO
	movem.l	(a0)+,d0-d5

	or.l	(a1)+,d0
	or.l	(a1)+,d1
	or.l	(a1)+,d2
	or.l	(a1)+,d3
	or.l	(a1)+,d4
	or.l	(a1)+,d5

	movep.l	d0,LINEWIDTH*0+LINOFFSET(a4)
	movep.l	d1,LINEWIDTH*1+LINOFFSET(a4)
	movep.l	d2,LINEWIDTH*2+LINOFFSET(a4)
	movep.l	d3,LINEWIDTH*3+LINOFFSET(a4)
	movep.l	d4,LINEWIDTH*4+LINOFFSET(a4)
	movep.l	d5,LINEWIDTH*5+LINOFFSET(a4)

	ENDM
	
; copies 3x7
; a0-a3; pointers for four masks
; a4 pointer to screen (output)
; uses d0-d6
copy3x7	MACRO
LINOFFSET	SET	0
	copy7
LINOFFSET	SET	LINOFFSET+7*LINEWIDTH
	copy7
LINOFFSET	SET	LINOFFSET+7*LINEWIDTH
	copy6
	ENDM
	

music_dma_init:
	move.l	music_seq,music_seq_dat
	move.l	music_seq+4,d0
	move.l	music_seq+8,d1
	
	move.b	d0,$ffff8907.w			;Start of sample
	lsr.l	#8,d0				;
	move.b	d0,$ffff8905.w			;
	lsr.l	#8,d0				;
	move.b	d0,$ffff8903.w			;
	
	move.b	d1,$ffff8913.w			;End of sample
	lsr.l	#8,d1				;
	move.b	d1,$ffff8911.w			;
	lsr.l	#8,d1				;
	move.b	d1,$ffff890f.w			;
	
	move.b	#%10000010,$ffff8921.w 		;25033Hz mono
	
	rts


music_dma_play:
	subq.l	#1,.once
	bne.s	.no
	move.b	#%00000001,$ffff8901.w		;Start sample without loop
.no:

	subq.l	#1,music_seq_dat
	bgt.s	.done

	;; move.w	#0,hbounce_idx	;reset bounce
	;; move.w	#0,hbounce_idx_next_vbl	;reset bounce

	move.l	music_seq_adr,a0
	cmp.l	#-1,12(a0)
	bne.s	.no_loop
	move.l	#music_seq-12,music_seq_adr
.no_loop:

	move.l	music_seq_adr,a0
	lea	12(a0),a0
	move.l	a0,music_seq_adr
	move.l	(a0)+,d0
	move.l	d0,music_seq_dat

	clr.b	$ffff8901.w			;kill sample playback

	move.b	3(a0),$ffff8907.w		;Start of sample
	move.b	2(a0),$ffff8905.w		;
	move.b	1(a0),$ffff8903.w		;

	move.b	7(a0),$ffff8913.w		;End of sample
	move.b	6(a0),$ffff8911.w		;
	move.b	5(a0),$ffff890f.w		;

	move.b	#%00000001,$ffff8901.w		;Start sample without loop

.done:	rts
.once:	dc.l	1

music_dma_exit:	clr.b	$ffff8901.w			;Kill sample playback
		rts

precalc_vdist:
	move.l	#vdist_pattern,a0
	move.l	#skipshift_mul,a3
	move.l	#wrap_tab+5*FONTHEIGHT*2,a4

SUBPIX_IDX	set	0
	rept	8
	move.w	#SUBPIX_IDX*VSKIP,d4
	move.l	#vdist+VDIST_LEN*2*3*SUBPIX_IDX,a2
	bsr	precalc_vdist2

SUBPIX_IDX	set	SUBPIX_IDX+1
	endr

	rts

precalc_vdist2:	

	move.w	#VDIST_LEN/2-1,d7
	move.l	#draw_offs,a5
.loop:
VDIST2_NIBBLE	MACRO
	INLINE
	;; remember, sin1024_6 has LSB=0
	move.w	0*VSKIP(a0,d4.w),d0
	move.w	1*VSKIP(a0,d4.w),d1
	move.w	2*VSKIP(a0,d4.w),d2
	move.w	3*VSKIP(a0,d4.w),d3

	ifeq	ENABLE_VDIST
	moveq	#0,d0
	moveq	#0,d1
	moveq	#0,d2
	moveq	#0,d3
	endc

	add.w	#4*VSKIP,d4
	and.w	#1023*2,d4

	moveq	#0,d6
	cmp.w	d3,d0
	bge	.pos

.neg:
	cmp.w	d1,d0
	slt	d5
	and.w	#4,d5
	or.w	d5,d6

	cmp.w	d2,d1
	slt	d5
	and.w	#2,d5
	or.w	d5,d6

	cmp.w	d3,d2
	slt	d5
	and.w	#1,d5
	or.w	d5,d6

	add.w	#POSSHIFT,d6		;pos starts at 001=8
	bra.s	.post_pos

.pos:
	cmp.w	d1,d0
	sgt	d5
	and.w	#4,d5
	or.w	d5,d6

	cmp.w	d2,d1
	sgt	d5
	and.w	#2,d5
	or.w	d5,d6

	cmp.w	d3,d2
	sgt	d5
	and.w	#1,d5
	or.w	d5,d6

.post_pos:
	add.w	d6,d6
	move.w	(a3,d6.w),d6	;skipshift mul

	ifeq	1
	move.w	(a4,d0.w),d3		; wrap tab
	else
	move.w	d0,d3
	asr.w	#1,d3
	endc

	;; add	d6,d3
	EINLINE
	ENDM

	VDIST2_NIBBLE
	move.w	d6,a6		;first skipshift
	move.w	d3,a1		;first vpos
	VDIST2_NIBBLE

	move.w	a1,d5
	add.w	d5,d5
	move.w	(a4,d5.w),d5		; wrap tab
	add.w	d5,d5
	move.w	(a5,d5.w),d5	;d5 offset for draw rout
	move.w	d5,(a2)+

	addq.w	#8,a6
	move.w	a6,(a2)+	;first skipshift+2lines

	sub.w	a1,d3		;d3 is now vpos diff

	addq.w	#2,d3
	add.w	d3,d3
	move.w	(a4,d3.w),d3		; wrap tab; FIXME, should not be necessary
	add.w	d3,d3		;lines->bytes
	add.w	d3,d3

	add.w	d6,d3		;add skipshift
	add.w	#SKIPMASK,d3
	sub.w	a6,d3

	move.w	d3,(a2)+

	dbra	d7,.loop

	; one lap wrap protection
	;; move.l	#vdist,a1
	sub.l	#VDIST_LEN*3,a2
	move.l	a2,a1
	move.w	#VDIST_LEN/2-1,d7
.loop2
	move.w	0(a1),0+VDIST_LEN*3(a1)
	move.w	2(a1),2+VDIST_LEN*3(a1)
	move.w	4(a1),4+VDIST_LEN*3(a1)
	;; move.w	VDIST_LEN*4(a1),VDIST_LEN*6(a1)
	;; move.w	VDIST_LEN*8(a1),VDIST_LEN*10(a1)
	;; move.w	VDIST_LEN*12(a1),VDIST_LEN*14(a1)
	addq.l	#6,a1
	dbra	d7,.loop2


	

	rts

precalc_hdist:	
	;; move.l	#sin1024_6,a0

SCROLL_IDX	set	0
	rept	4
	move.l	#sin1024_15,a0
	move.l	#SCROLL_IDX*2,a4
	move.l	#hdist+SCROLL_IDX*(2+2)*(HDIST_LEN+HDIST_WRAPLEN),a1
	move.l	#hdist_first_line+SCROLL_IDX*(HDIST_LEN+HDIST_WRAPLEN),a5
	move.l	#hdist_first_color+2*SCROLL_IDX*(HDIST_LEN+HDIST_WRAPLEN),a6

	bsr	precalc_hdist2
SCROLL_IDX	set	SCROLL_IDX+1
	endr

	
	move.l	#sin1024,a0
	move.l	#hbounce,a1
	moveq	#0,d0
	move.w	#2*HBOUNCE_LEN-1,d7
.loop5:
	move.w	(a0,d0.w),d1
	;; add.w	#2*(512/HBOUNCE_LEN),d0 ;wrap at half period
	add.w	#2*6,d0 ;wrap at half period
	and.w	#511*2,d0
	asr.w	#8,d1
	asr.w	#2,d1		;-32:31, half period: 0:31
	lsl.w	#2,d1		;bounce idx for hdist (4 bytes)
	ifeq	ENABLE_BOUNCE
	moveq	#0,d1
	endc
	move.w	d1,(a1)+
	dbra	d7,.loop5

	rts

precalc_hdist2:
	;; move.l	#colors,a2
	move.l	#0,a2
	move.w	#0,d0

	moveq	#0,d6

	;;  d0 sin index
	;; d1 sin value -> hscroll
	;; d2 words to skip
	;; d3 next prev words to skip
	;; d4
	;; d5 linewidth offset
	;; d6 prev words to skip
	;; d7 loop counter
	;; a0 sin1024_15
	;; a1 hdist output
	;; a2
	;; a3
	;; a4 scroll offset
	;; a5 hdist_first_line
	;; a6 hdist_first_color
do_pixelshift	MACRO
	ifeq	0
	move.w	d0,d1
	add.w	d1,d1
	add.w	d0,d1		;3x freq
	add.w	#256*2,d1	;phase offset
	and.w	#1023*2,d1
	move.w	(a0,d1.w),d1
	;; asr.w	#1,d1
	add.w	(a0,d0.w),d1
	else
	move.w	(a0,d0.w),d1
	endc
	add.w	#HSKIP,d0
	and.w	#1023*2,d0	; wrap sintab
	asr.w	#5,d1	; remove pre-shift (-32k+32k -> -32+31
	asr.w	#5,d1
	add.w	#32,d1		;0..63

	ifeq	ENABLE_HDIST
	moveq	#1,d1
	endc
	add.w	a4,d1		;scroll

	move.w	d1,d2
	and.w	#$f,d1
	bne.s	.nonzero\@
	addq.w	#1,d2
.nonzero\@:
	move.w	d2,d1
	and.w	#$0f0,d2
	lsr.w	#2,d2		;words to skip

	;; store words to skip
	move.w	d2,d3
	;; sub.b	#12,d3
	add.b	d3,d3		;4
	move.b	d3,(a5)+

	;; keep track of previous lines' words to skip
	move.w	d2,d3		;next prev
	sub.w	d6,d2		;sub prev
	move.w	d3,d6

	add.w	#(LINEWIDTH-224)/2-4,d2

	move.b	d2,2(a1)	;hskip
	move.b	d1,3(a1)	;hscroll

	;; palette
	ifeq	1
	neg.w	d1
	add.w	d1,d1		;"static" playfield
	else
	ifeq	1
	sub.w	a4,d1		;undo scroll
	neg.w	d1
	else
	sub.w	a4,d1
	neg.w	d1
	add.w	d1,d1
	add.w	d1,d1
	endc
	endc
	and.l	#$0e,d1
	move.w	d1,(a1)	;palette address
	addq.l	#4,a1
	ENDM

	move.w	#(HDIST_LEN+HDIST_WRAPLEN)-1,d7
.loop:
	do_pixelshift
	dbra	d7,.loop
	sub.l	#(2+2)*(HDIST_LEN+HDIST_WRAPLEN),a1

	;; move.l	#hdist_first_color,a6
	move.w	#(HDIST_LEN+HDIST_WRAPLEN)-1,d7
.loop3:
	move.w	(a1),(a6)+
	addq.l	#4,a1
	dbra	d7,.loop3
	sub.l	#(2+2)*(HDIST_LEN+HDIST_WRAPLEN),a1
	sub.l	#2*(HDIST_LEN+HDIST_WRAPLEN),a6
	
	;; diff palette address
	add.l	#4,a1
	;; move.l	#hdist_first_color+2,a0
	add.l	#2,a6
	move.w	#(HDIST_LEN+HDIST_WRAPLEN)-1-1,d7 ;one line lookahead
.loop4:
	move.w	-2(a6),d0
	move.w	(a6)+,d1
	sub.w	d0,d1
	;; add.w	d1,d1		;FIXME
	add.w	#32-16,d1
	move.w	d1,(a1)
	addq.l	#4,a1
	dbra	d7,.loop4
	sub.l	#(2+2)*(HDIST_LEN+HDIST_WRAPLEN),a1
	move.w	#0,(a1)	;fix first FIXME
	
	rts


update_frame:
	move.w	scroll_subidx_next_vbl,scroll_subidx
	move.w	hbounce_idx_next_vbl,hbounce_idx
	move.w	vbounce_idx_next_vbl,vbounce_idx
	subq.b	#1,slomo_ctr
	bmi.s	.update
	rts
.update:
	move.b	#SLOMO,slomo_ctr

	add.w	#-2*3,vdist_idx
	and.w	#(8*VDIST_LEN-1)*2,vdist_idx
	add.w	#4*3,hdist_idx
	cmp.w	#HDIST_LEN*4,hdist_idx
	blt.s	.no_hdist_wrap
	move.w	#0,hdist_idx
.no_hdist_wrap:
	;; and.w	#(HDIST_LEN-1)*4,hdist_idx
	ifeq	0
	move.w	hbounce_idx,d0
	add.w	#2,d0
	ifeq	1
	and.w	#(HBOUNCE_LEN-1)*2,d0
	else
	cmp	#HBOUNCE_LEN,d0
	blt.s	.nobouncewrap
	moveq	#0,d0
.nobouncewrap:
	endc
	move.w	d0,hbounce_idx_next_vbl
	else
	add.w	#2,hbounce_idx
	and.w	#(HBOUNCE_LEN-1)*2,hbounce_idx	; wrap sintab
	endc

	move.w	vbounce_idx,d0
	add.w	#2*5,d0
	and.w	#(1024-1)*2,d0
	move.w	d0,vbounce_idx_next_vbl

	move.w	scroll_subidx,d0
	ifne	ENABLE_SCROLL
	addq.w	#1,d0
	endc
	and.w	#3,d0
	move.w	d0,scroll_subidx_next_vbl
	cmp.w	#0,d0 ;scroll_ptr must be updated one vbl earlier due to double-buffer
	bne.s	.nowrap
	
	ifne	ENABLE_SCROLL
	add.l	#2,scroll_ptr
	endc
	;; cmp.l	#scrolltext_prep+SCROLL_LENGTH_BYTES,scroll_ptr
	move.l	scroll_ptr_wrap,d0
	move.l	scroll_ptr,d1
	cmp.l	d0,d1
	blt.s	.nowrap
	move.l	#scrolltext_prep,scroll_ptr
.nowrap:

	ifeq	1
	move.w	scroll_subidx,d0
	addq.w	#1,d0
	move.w	d0,d1
	and.w	#3,d0
	and.w	#4,d1
	add.w	d1,d1
	;; moveq	#8,d1		;FIXME
	move.w	d0,scroll_subidx
	move.l	scroll_ptr,a3
	add.w	d1,a3
	;; cmp.l	#scrolltext_prep+SCROLL_LENGTH_BYTES,a3
	cmp.l	scrolltext_prep_wrap,a3
	blt.s	.nowrap
	move.l	#scrolltext_prep,a3
.nowrap:
	move.l	a3,scroll_ptr
	endc
	
	rts





wrap_tab	ds.w	11*FONTHEIGHT


init_wrap_tab:
	move.l	#wrap_tab,a1
	move.w	#11*FONTHEIGHT-1,d7
	move.w	#-5*FONTHEIGHT,d6
.loop
	move.w	d6,d0

.neg:
	cmp.w	#0,d0
	bge.s	.not_neg
	add.w	#FONTHEIGHT,d0
	bra.s	.neg

.not_neg:
	cmp.w	#FONTHEIGHT,d0
	blt.s	.no_wrap
	sub.w	#FONTHEIGHT,d0
	bra.s	.not_neg
.no_wrap:

	;; add.w	d0,d0
	;; add.w	d0,d0

	move.w	d0,(a1)+
	add.w	#1,d6
	dbra	d7,.loop

	rts


skipshift_mul:
	dc.w	NEG000SHIFT;	equ	0*SKIPSHIFT
	dc.w	NEG001SHIFT;	equ	1*SKIPSHIFT
	dc.w	NEG010SHIFT;	equ	2*SKIPSHIFT
	dc.w	NEG011SHIFT;	equ	0*SKIPSHIFT ;x
	dc.w	NEG100SHIFT;	equ	3*SKIPSHIFT
	dc.w	NEG101SHIFT;	equ	4*SKIPSHIFT
	dc.w	NEG110SHIFT;	equ	0*SKIPSHIFT ;x
	dc.w	NEG111SHIFT;	equ	0*SKIPSHIFT ;x
	dc.w	POS000SHIFT;	equ	0*SKIPSHIFT
	dc.w	POS001SHIFT;	equ	5*SKIPSHIFT
	dc.w	POS010SHIFT;	equ	6*SKIPSHIFT
	dc.w	POS011SHIFT;	equ	0*SKIPSHIFT ;x
	dc.w	POS100SHIFT;	equ	7*SKIPSHIFT
	dc.w	POS101SHIFT;	equ	8*SKIPSHIFT
	dc.w	POS110SHIFT;	equ	0*SKIPSHIFT ;x
	dc.w	POS111SHIFT;	equ	0*SKIPSHIFT ;x
	
	dc.w	SKIPSHIFT*0
	dc.w	SKIPSHIFT*1
	dc.w	SKIPSHIFT*2
	dc.w	SKIPSHIFT*3
	dc.w	SKIPSHIFT*4
	dc.w	SKIPSHIFT*5
	dc.w	SKIPSHIFT*6
	dc.w	SKIPSHIFT*7
	dc.w	SKIPSHIFT*8
	dc.w	SKIPSHIFT*9
	dc.w	SKIPSHIFT*10
	dc.w	SKIPSHIFT*11
	dc.w	SKIPSHIFT*12
	dc.w	SKIPSHIFT*13
	dc.w	SKIPSHIFT*14
	dc.w	SKIPSHIFT*15




CHAR_SETUP_6	MACRO
	move.l	(a7)+,a0	;3n
	move.l	(a7)+,a1	;3n
NOPS_LEFT	set	NOPS_LEFT-6

	ENDM
	
	;; a3 char pointers to font
	;; a0-a1 mask1-2
	;; a4 output (screen)
	;; a2 dist offsets
	;; char setup 12n
;; draw_char8	MACRO
;; 	move.l	(a3)+,a0	;3n
;; 	move.l	(a3)+,a1	;3n
	
;; 	add.w	(a2)+,a0	;3n
;; 	add.w	(a2)+,a1	;3n

;; 	copy3x7
;; 	ENDM


COPY_COLORSa18	MACRO
	add.w	(a5)+,a6	  ;12c/3n
	movem.l	(a6)+,d0-d3	;44c/11n
	move.l	d0,$ffff8250.w ;16c/4n
	ENDM
COPY_COLORSb9	MACRO
	movem.l	d1-d3,$ffff8254.w	    ;36c/9n
	ENDM

COPY_COLORSa14	MACRO
	add.w	(a5)+,a6	  ;12c/3n
	movem.l	(a6)+,d0-d3	;44c/11n
	ENDM
COPY_COLORSb11	MACRO
	movem.l	d0-d3,$ffff8250.w	    ;44c/11n
	ENDM
	

OPEN_BORDERS	MACRO
	add.w	(a5)+,a6	  ;12c/3n
	move.w	d7,$ffff820a.w			;3 Right border
	move.b	d7,$ffff820a.w			;3

	;; 26
	;; COPY_COLORSa18
	;; dcb	4,$4e71
	move.b	(a5)+,$ffff820f.w	;16, hskip
	movem.l	(a6)+,d0-d3	;44c/11n
	movem.l	d0-d3,$ffff8250.w ;11n

	move.b	d7,$ffff8260.w			;3n Left border
	move.w	d7,$ffff8260.w			;3n
	move.b	(a5)+,$ffff8265.w	;16, hscroll
NOPS_LEFT	set	128-45
	ENDM

OPEN_BORDERS_lower	MACRO
	add.w	(a5)+,a6	  ;12c/3n
	move.l	(a6)+,d0	  ;3n, fetch first color
	move.w	d7,$ffff820a.w			;3 Right border
	move.b	d7,$ffff820a.w			;3

	;; 26
	move.b	(a5)+,$ffff820f.w	;4n, hskip
	movem.l	(a6)+,d1-d3	;9n
	nop
	movem.l	d0-d2,$ffff8250.w ;9n
	move.w	d7,$ffff820a.w			;3 lower border

	move.b	d7,$ffff8260.w			;3n Left border
	move.w	d7,$ffff8260.w			;3n
	move.b	(a5)+,$ffff8265.w	;4n, hscroll
	move.l	d3,$ffff825c.w	    ;4n
	move.b	d7,$ffff820a.w			;3, lower border
	;; don't count the 3 extra nops earlier - must start OPEN_BORDERS_lower 3 nops early
NOPS_LEFT	set	128-52
	ENDM

rbstart:
	add.w	(a5)+,a6	  ;12c/3n 2b
	move.w	d7,$ffff820a.w			;3n 4b Right border
	move.b	d7,$ffff820a.w			;3n 4b
rbend:	

	;; free: d4-d6/a0-a4
	;; trashed each line: d0-d3

	;; screen output	a4
	;; 2xfontdata		a0-a1
	;; vdist		a2

	;; 5 lines -> use d0-d4

	;; 4 scanlines to copy 20 lines of an 8 pixel strip
lower_border:
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;224
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;225
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;226
	OPEN_BORDERS
	dcb	NOPS_LEFT-3,$4e71	;227
	OPEN_BORDERS_lower
	dcb	NOPS_LEFT,$4e71	;228
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;229
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;230
	OPEN_BORDERS
	dcb	NOPS_LEFT-4,$4e71	;231
	rts

	;; start at 248+1
	;; reset at 260
empty_lines:
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;249
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;250
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;251
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;252
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;253
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;254
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;255
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;256
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;257
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;258
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;259
	OPEN_BORDERS
	dcb	NOPS_LEFT-3,$4e71	;260
	move.b	d7,$ffff8207.w ;3n 4b, back up to top
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;261
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;262
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;263
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;264
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;265
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;266
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;267
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;268
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;269
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;270
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;271
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;272
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;273
	OPEN_BORDERS
	dcb	NOPS_LEFT,$4e71	;274
	OPEN_BORDERS
	rts


draws:
LINOFFSET2	SET	20
	rept	20
	INLINE
.draws_start:
	;;  418 bytes
	;; bra.s	.noreset		;3n 2b
	move.b	d7,$ffff8207.w ;3n 4b, back up to top
.noreset:
	
	OPEN_BORDERS
	CHAR_SETUP_6
LINOFFSET	SET	LINOFFSET2
	COPY5_63
	dcb	NOPS_LEFT,$4e71
	OPEN_BORDERS
	
LINOFFSET	SET	LINOFFSET+5
	COPY5_63
	dcb	NOPS_LEFT,$4e71
	OPEN_BORDERS
	
LINOFFSET	SET	LINOFFSET+5
	COPY5_63
	dcb	NOPS_LEFT,$4e71
	OPEN_BORDERS		;NOPS_LEFT gets reset
	
LINOFFSET	SET	LINOFFSET+5
	COPY5_63
	;; move.l	a4,d0		;1n
	;; addq.w	#7,d0		;1n  word should not overflow!
	;; and.w	#$fff9,d0		;2n keep 1 or 0/8
	;; move.l	d0,a4		;1n
	;; dcb	NOPS_LEFT-5-4,$4e71
	;; OPEN_BORDERS		;4 lines

	rts
.draws_end:
DRAW_LEN	SET	.draws_end-.draws_start
	EINLINE
LINOFFSET2	SET	LINOFFSET2-1
	endr

draw_pause_noreset1:
	addq.w	#1,a4
	dcb	NOPS_LEFT-2-4-4,$4e71
	rts
draw_pause_noreset7:
	addq.w	#7,a4
	dcb	NOPS_LEFT-2-4-4,$4e71
	rts

draw_pause_reset1:
	addq.w	#1,a4
	dcb	NOPS_LEFT-2-4-3-4,$4e71
	rts
draw_pause_reset7:
	addq.w	#7,a4
	dcb	NOPS_LEFT-2-4-3-4,$4e71
	rts
	
draw_ptrs:
LINOFFSET2	SET	0
	rept	FONTHEIGHT
	dc.l	draws+LINOFFSET2*DRAW_LEN
LINOFFSET2	SET	LINOFFSET2+1
	endr
	
draw_offs:
LINOFFSET2	SET	0
	rept	FONTHEIGHT
	dc.w	LINOFFSET2*DRAW_LEN
LINOFFSET2	SET	LINOFFSET2+1
	endr

setup_timera:
	clr.b   $fffffa19.w      ;stop timer a
	move.b   #97,$fffffa1f.w      ;number of counts
	move.l   #remove_top_border,$134.w
	move.b   #4,$fffffa19.w      ;set Timer A to divide by 50
	bset   #5,$fffffa07.w      ;Timer A enable
	bset   #5,$fffffa13.w
	
	rts
	
draw_scroll:
	DBG_C0	#$330
	ifeq	1
	move.w	#1500,d7
.loop:
	dbra	d7,.loop
	endc
	DBG_C0	#$700

	bsr	update_frame

	DBG_C0	#$070

	move.l	#hdist_first_line,a0
	move.w	scroll_subidx,d0
	and.w	#3,d0
	mulu	#(HDIST_LEN+HDIST_WRAPLEN),d0
	add.w	d0,a0
	move.w	hdist_idx,d0
	move.l	#hbounce,a1
	move.w	hbounce_idx,d1
	move.w	(a1,d1.w),d1
	moveq	#0,d1		;FIXME, disable hbounce in first_line
	lsr.w	#2+1,d1
	lsr.w	#2,d0
	add.w	d1,d0
	move.b	(a0,d0.w),d0
	;; sub.b	#26,d0
	move.b	d0,screen_ptr_low

	move.l	#hdist_first_color,a0
	move.w	scroll_subidx,d0
	and.w	#3,d0
	mulu	#2*(HDIST_LEN+HDIST_WRAPLEN),d0
	add.w	d0,a0
	move.w	hdist_idx,d0
	move.l	#hbounce,a1
	move.w	hbounce_idx,d1
	move.w	(a1,d1.w),d1
	;; moveq	#0,d1		;FIXME, disable hbounce in first_color
	lsr.w	#1,d1
	and.w	#$fc,d1
	move.l	#hdist,a5
	ifeq	0		;disable bouncing of waveform
	add.w	d0,a5
	endc
	;; add.w	d1,d0
	lsr.w	#1,d0
	move.l	#colors,a6
	add.w	(a0,d0.w),a6

	move.w	scroll_subidx,d0
	and.w	#3,d0
	mulu	#(2+2)*(HDIST_LEN+HDIST_WRAPLEN),d0
	add.w	d0,a5
	
	sub.w	(a5),a6	;FIXME? corrected or not?
	;; move.w	(a1,d1.w),d1
	lsl.w	#3,d1		;FIXME: vbounce double speed?
	add.w	d1,a6		;bounce

	move.l	a6,colors_ptr
	move.l	a5,hdist_ptr


	move.b	#0,$FFFF8265.w	;pix-scroll
	move.b	#(LINEWIDTH-224)/2-4,$FFFF820F.w	;skip

	move.l	screen_ptr,d0
	lsr.l	#8,d0
	move.l	d0,screen_ptr8
	move.b	d0,screen_ptr_med


	
	move.l	#vdist,a2
	move.w	vdist_idx,d0
	ifeq	1
	;; shuffle bits (3 LSBs to 'MSBs')
	;; FIXME: this depends on VDIST_LEN=512/4
	moveq	#3,d2
	sub.w	scroll_subidx_next_vbl,d2 ;FIXME vdist
	lsl.w	#1+1,d2			  ;1 for word, 1 for 2 pixels per subscroll
	add.w	d2,d0
	;; addq.w	#4*2,d0
	move.w	d0,d1
	and.w	#$3f0,d0
	lsr.w	#2,d0
	and.w	#$e,d1
	lsl.w	#8,d1
	or.w	d1,d0
	else
	;; shuffle bits (3 LSBs to 'MSBs')
	;; FIXME: this depends on VDIST_LEN=512/4*2
	moveq	#3,d2
	sub.w	scroll_subidx_next_vbl,d2 ;FIXME vdist
	lsl.w	#1+1,d2			  ;1 for word, 1 for 2 pixels per subscroll
	add.w	d2,d0
	;; addq.w	#4*2,d0
	move.w	d0,d1
	and.w	#$7f0,d0
	lsr.w	#2,d0
	and.w	#$e,d1
	lsl.w	#8,d1
	lsl.w	#1,d1
	or.w	d1,d0

	endc

	move.w	d0,d1
	lsr.w	#1,d1
	add.w	d1,d0

	add.w	d0,a2

	ifeq	1
	move.l	#hbounce,a1
	;; move.w	hbounce_idx,d1
	move.w	hbounce_idx_next_vbl,d1
	;; FIXME: add something to get hbounce_idx for next update?
	move.w	(a1,d1.w),d1
	;; and.w	#$38,d1		;2 LSB 0, next downshift
	and.w	#$78,d1		;2 LSB 0, next downshift
	;; mul by (4*VDIST_LEN*2*2)
	lsl.w	#8,d1
	;; add.w	d1,a2		;bounce
	endc
	
	DBG_C0	#$330

	move.w	scroll_subidx,d0
	and.w	#3,d0
	add.w	d0,d0
	move.l	#scroll_colors,a1
	;; move.w	(a1,d0.w),$ffff8240.w
	DBG_C0	(a1,d0.w)

	;; a2 vdist
	;; a5 hdist
	;; a6 colors
	ifeq	1
	move.l	#hbounce,a1
	move.w	hbounce_idx_next_vbl,d1
	move.w	(a1,d1.w),d1
	lsr.w	#3,d1
	and.w	#-2,d1
	lea	draw_offs,a3
	move.w	(a3,d1.w),d6	;d1 bounce in code bytes
	else
	move.l	#sin1024,a1
	move.w	vbounce_idx_next_vbl,d1
	move.w	(a1,d1.w),d1
	asr.w	#8,d1		;-32k:32k -> -128:127
	add.w	#128,d1
	lsr.w	#1,d1
	ext.l	d1
	divu	#20,d1
	swap	d1		;get remainder
	ifeq	ENABLE_VBOUNCE
	moveq	#0,d1
	endc
	add.w	d1,d1
	;; moveq	#0,d1
	;; and.w	#-2,d1
	lea	draw_offs,a3
	move.w	(a3,d1.w),d6	;d1 bounce in code bytes
	endc

	move.w	#$2700,sr
	move.l	sp,my_stack
	move.l	#call_stack,sp

	lea	draws,a6
	lea	font_buffer,a1
	move.l	scroll_ptr,a3
	;; d6 wrap offset
PUSH_VDIST	MACRO
	move.w	(a2)+,d0	;grab draw offset
	sub.w	d6,d0
	bge.s	.no_wrap\@
	add.w	#FONTHEIGHT*DRAW_LEN,d0
.no_wrap\@:
	lea	\1(a6,d0.w),a4
	;; ifne	\1
	;; add.l	#\1,a4
	;; endc
	move.l	a4,(sp)+	;draw code ptr

	;; FIXME: can be optimized. Perhaps store the full long
	;; pointers to the preshifted font instead
	moveq	#0,d0		;1n +
	move.w	(a3)+,d0	;2n |
	lsl.l	#2,d0		;3n |
	lea	(a1,d0.l),a4	;3n `-> 3n long fetch
	add.w	(a2)+,a4
	move.l	a4,(sp)+	;first skipshift

	add.w	(a2)+,a4
	move.l	a4,(sp)+	;second skipshift

	;; move.l	(a3)+,a4
	;; add.w	(a2)+,a4
	;; move.l	a4,(sp)+	;first skipshift
	;; move.l	(a3)+,a4
	;; add.w	(a2)+,a4
	;; move.l	a4,(sp)+	;second skipshift
	
	addq.l	#4,sp		;code for reset etc
	ENDM

	PUSH_VDIST	4+2+4+4	;noreset, skip right border
	PUSH_VDIST	4
	PUSH_VDIST	4
	PUSH_VDIST	4
	PUSH_VDIST	4

C10	MACRO
	PUSH_VDIST	0	;reset
	PUSH_VDIST	4
	PUSH_VDIST	4
	PUSH_VDIST	4
	PUSH_VDIST	4
	
	PUSH_VDIST	0	;reset
	PUSH_VDIST	4
	PUSH_VDIST	4
	PUSH_VDIST	4
	PUSH_VDIST	4
	ENDM

	C10
	C10
	C10
	C10
	C10			;220 lines, 55 chars

	PUSH_VDIST	0	;224 lines, 56 chars
	addq.l	#4,sp		;lower border, 8 lines
	PUSH_VDIST	4	;236/57
	PUSH_VDIST	4	;240/58

	PUSH_VDIST	0	;59/244 reset
	PUSH_VDIST	4	;60/248
	ifeq	1
	PUSH_VDIST	4	;61/252
	PUSH_VDIST	4	;62/256
	PUSH_VDIST	4	;63/260
	endc

	move.l	#empty_lines,(sp)+
	
	;; sub.l	#(58)*6,a2

	move.l	#return_from_callstack,(sp)+
	move.l	my_stack,sp

	move.w	#$2300,sr	;enable VBL
	rts
	
remove_top_border:
	;; clr.b	$fffffa19.w			;Stop Timer A
	move.l	d0,-(sp)
	move.l	sp,my_stack

	;; d7 overscan
	;; a4 screen
	;; 
	DBG_C0	#$000

	lea	$ffff8209.w,a0	;scr_low
	move.l  screen_ptr,a4
	add.w	#$300,a4	;skip three lines
	moveq	#0,d0
	move.b	screen_dbl_buffer,d0
	lsl.w	#8,d0
	add.w	d0,a4

	moveq	#0,d7
	move.b	screen_dbl_buffer,d7
	eori	#$20,d7
	move.b	d7,screen_dbl_buffer
	or.b	#3,d7		;for overscan code later
	add.b	screen_ptr_med,d7

	move.l	scroll_ptr,a3
	move.l	hdist_ptr,a5
	move.l	colors_ptr,a6
	move.b	screen_ptr_low,d3
	;; a4 screen
	;; d7 overscan/screen address reset
	;; move.w	#$2700,sr

	subq.b	#1,d7
	move.b	d7,$ffff8207.w ;16, back up to top (3 lines)
	addq.b	#1,d7
	lsr.b	#1,d3
;	neg.b	d3
	add.b	#(256-160)/2,d3
	move.b	d3,$ffff820f.w ;3n  first line offset

	move.w	#$2100,sr			;Enable HBL
	stop	#$2100				;Wait for HBL
	move.w	#$2700,sr			;Stop all interrupts
	clr.b	$fffffa19.w			;Stop Timer A

	dcb.w 	84,$4e71			;Have fun for a bit

	move.b	#0,$ffff820a.w			;Remove the top border
	dcb.w 	9,$4e71				;
	move.b	#2,$ffff820a.w			;
	move.l	#call_stack,sp
	
	;; DHS style sync
		moveq	#127,d1				;
.sync:		tst.b	(a0)				;
		beq.s	.sync				;
		move.b	(a0),d2				;
		sub.b	d2,d1				;
		lsr.l	d1,d1				;

	move.w	#$000,$ffff8240.w ;16

;	move.b	d7,$ffff8207.w ;16, back up to top (3 lines)
	;; d7 3->2
	subq.w	#1,d7
	dcb.w	27+6,$4e71			;Time for user to set up registers etc

	move.l	(sp)+,a0

	add.w	(a5)+,a6	  ;12c/3n
;	move.b	d3,$ffff8209.w ;3n  first line offset

	jmp	(a0)
return_from_callstack:	
	move.l	my_stack,sp

	
	DBG_C0	#$030

	move.l	(sp)+,d0
	move.w	#$2300,sr	; enable VBL

	rte




	even
	section	data

colors:
	incbin	colors3.bin
	even

font:
	incbin  font2.bin
	even

; signed 16bit one period (-32768..32767)
sin1024:
	incbin	sin1024.bin

sin1024_6	dcb.w	1024*2,0
vdist_pattern	dcb.w	1024*2,0
sin1024_15	dcb.w	1024,0

HSKIP	EQU	2*2
	;; Make sure 1*HSKIP*HDIST_LEN is a multiple of 1024 (one sine period)
HDIST_LEN	EQU	512
HDIST_WRAPLEN	EQU	274	
	even
hdist_first_line:	ds.b	4*(HDIST_LEN+HDIST_WRAPLEN)
	even
hdist_first_color:	ds.w	4*(HDIST_LEN+HDIST_WRAPLEN)
	even
hdist	ds.b	4*(2+2)*(HDIST_LEN+HDIST_WRAPLEN)
	ds.b	100		;buffer?
	even
hdist_idx	dc.w	0

hbounce	ds.w	2*HBOUNCE_LEN
hbounce_idx	dc.w	0
hbounce_idx_next_vbl	dc.w	0

vbounce_idx	dc.w	0
vbounce_idx_next_vbl	dc.w	0


	
	
VSKIP	EQU	2*1
	;; Make sure 4*VSKIP*VDIST_LEN is a multiple of 1024 (one sine period)
VDIST_LEN	EQU	512/4*2
	
vdist_idx	dc.w	0+64
	;; 2x4 subpixel buffers, VDIST_LEN, 2x wrap protection, 1.5w per entry (3 per 2 nibbles)
vdist	ds.w	2*4*VDIST_LEN*3

	
	
;pal dc.w	$000,$227,$005,$740,$730,$720,$710,$777,$111,$121,$8a8,$8b8,$8c8,$8d8,$060,$070
pal	 dc.w	$070,$227,$005,$654,$543,$432,$321,$777
;	dc.w	$000,$227,$005,$740,$730,$720,$710,$777
	dc.w $777,$666,$555,$444,$333,$222,$111,$002


scrolltext
	dc.b	"                     "
	dc.b	"yeah! i hope this will be the third best fullscreen "
	dc.b	"distorter ever.       "
	dc.b	"code by solomon of gash (and corrosion), "
	dc.b	"everything else as in the original ulm screen "
	dc.b	"(only this time in full xy dist and 25 khz sound, "
	dc.b	"but requiring an ste...) "
	dc.b	"source code and more info on github (sigfridsson:paradst2) "
	dc.b	"                   "
	dc.b	-1
	even
scrolltext_end:
;	rept 20
;	dc.l	8,9,10,11
				;	endr
	rept	8
	dc.l	38
	endr
	dc.l	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
	rept	8
	dc.l	38
	endr
	dc.l	0,1,2,3,4,5,6,7,8,9,10,11
	;; ,12,13,14,15,16,17,18,19
	rept	20
	dc.l	38
	endr
	dc.l	20,21,22,23,24,25,26,27,28,29
	dc.l	30,31,32,33,34,35,36,37,38,39
	dc.l	39,39,39,39
	ds.l	30
	dc.l	-1
scroll_ptr  dc.l	0
scroll_ptr_wrap	dc.l	0
scroll_subidx	dc.w	0
scroll_subidx_next_vbl	dc.w	0
scroll_colors	dc.w	$700,$070,$007,$770
fontconv	include	"fontconv.s"
	dc.b	-1,-1,-1
	even

music_seq:
	dc.l	164,sample,sample+82108
	dc.l	164,sample,sample+82108
	dc.l	164,sample+82108,sample+2*82108
	dc.l	164,sample+82108,sample+2*82108
	dc.l	-1,sample,sample
music_seq_adr:	dc.l	music_seq
music_seq_dat:	dc.l	0
sample	incbin	you.bin	
	even

	;; 64 copy routines stack + extra
call_stack	;; ds.l	20+64*3
	dc.l	0,0,0,draw_pause_noreset1
	dc.l	0,0,0,draw_pause_noreset7
	dc.l	0,0,0,draw_pause_noreset1
	dc.l	0,0,0,draw_pause_noreset7
	dc.l	0,0,0,draw_pause_reset1

	rept	5		;5x10
	dc.l	0,0,0,draw_pause_noreset7
	dc.l	0,0,0,draw_pause_noreset1
	dc.l	0,0,0,draw_pause_noreset7
	dc.l	0,0,0,draw_pause_noreset1
	dc.l	0,0,0,draw_pause_reset7

	dc.l	0,0,0,draw_pause_noreset1
	dc.l	0,0,0,draw_pause_noreset7
	dc.l	0,0,0,draw_pause_noreset1
	dc.l	0,0,0,draw_pause_noreset7
	dc.l	0,0,0,draw_pause_reset1
	endr

	dc.l	0,0,0,draw_pause_noreset7 ;56/224
	dc.l	lower_border		;232
	dc.l	0,0,0,draw_pause_noreset1 ;57/236
	dc.l	0,0,0,draw_pause_reset7	;58/240
	
	dc.l	0,0,0,draw_pause_noreset1 ;59/244
	dc.l	0,0,0,draw_pause_noreset7 ;60/248
	dc.l	0,0,0,draw_pause_noreset1 ;61/252
	dc.l	0,0,0,draw_pause_noreset7 ;62/256
	dc.l	0,0,0,draw_pause_reset1	;63/260
	
	dc.l	return_from_callstack


	ds.l	32
my_stack:
	ds.l	1
	
	
	section	bss

screenad:	ds.l	1

key ds.w	1
	

fontconv2	ds.b	256*2
	;; 2xwrap protection, 16char-8char, average length 2 16chars
scrolltext_prep	ds.w	2*(scrolltext_end-scrolltext)*2*2
	ds.l	100

hdist_ptr	ds.l	1
colors_ptr	ds.l	1
	
screen_ptr  ds.l	1
screen_ptr8  ds.l	1
screen_ptr_low	ds.b	1
screen_ptr_med	ds.b	1
screen_dbl_buffer	ds.b	1
slomo_ctr	ds.b	1
	even
;; screen_buffer   ds.b (SCREENSIZE+256)
;; screen_buffer   ds.b (SCREENSIZE*2+65536)	
screen_buffer   ds.b (SCREENSIZE*2+$2000)

; inner: 4 bytes bitplanes
;	FONTHEIGHT2
;	vertical shift (-2,-1,0,1,2)
;	masks
;	characters (8-pixel wide)
font_buffer ds.b (NUMCHARS8*NUMMASKS*NUMSHIFTS*FONTHEIGHT2*4)

	end



